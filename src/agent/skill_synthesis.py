"""
Skill synthesis for agent-generated skills.

Handles validation, testing, and persistence of skills
generated by the LLM during gameplay.
"""

import logging
from dataclasses import dataclass
from typing import Any

from src.sandbox.validation import validate_skill
from src.skills import SkillExecutor, SkillLibrary

logger = logging.getLogger(__name__)


@dataclass
class SynthesisResult:
    """Result of skill synthesis attempt."""

    success: bool
    skill_name: str
    error: str | None = None
    validation_errors: list[str] = None
    test_result: dict | None = None
    persisted: bool = False

    def __post_init__(self):
        if self.validation_errors is None:
            self.validation_errors = []


class SkillSynthesizer:
    """
    Handles synthesis of agent-generated skills.

    Validates generated code, optionally tests it, and
    manages persistence to the skill library.

    Example usage:
        synthesizer = SkillSynthesizer(library, executor)

        result = await synthesizer.synthesize(
            name="flee_from_monster",
            code=generated_code,
            test_before_save=True,
        )

        if result.success:
            print(f"Created skill: {result.skill_name}")
    """

    def __init__(
        self,
        library: SkillLibrary,
        executor: SkillExecutor | None = None,
        auto_save: bool = True,
        min_success_rate: float = 0.3,
    ):
        """
        Initialize the skill synthesizer.

        Args:
            library: Skill library for persistence
            executor: Optional executor for testing skills
            auto_save: Whether to automatically save successful skills
            min_success_rate: Minimum success rate for auto-saving
        """
        self.library = library
        self.executor = executor
        self.auto_save = auto_save
        self.min_success_rate = min_success_rate

        # Track synthesis attempts
        self._attempts: list[SynthesisResult] = []
        self._failed_codes: dict[str, list[str]] = {}  # skill_name -> [failed codes]

    async def synthesize(
        self,
        name: str,
        code: str,
        test_before_save: bool = False,
        test_params: dict[str, Any] | None = None,
        force_save: bool = False,
    ) -> SynthesisResult:
        """
        Synthesize a new skill from generated code.

        Args:
            name: Name for the skill
            code: Python code for the skill
            test_before_save: Whether to test before saving
            test_params: Parameters for test execution
            force_save: Save even if test fails

        Returns:
            SynthesisResult with outcome
        """
        result = SynthesisResult(success=False, skill_name=name)

        # Validate the code
        validation = validate_skill(code, name)
        if not validation.valid:
            result.validation_errors = validation.errors
            result.error = f"Validation failed: {'; '.join(validation.errors)}"
            self._record_failure(name, code, result.error)
            self._attempts.append(result)
            return result

        # Check for duplicate name
        if self.library.exists(name) and not force_save:
            result.error = f"Skill '{name}' already exists"
            self._attempts.append(result)
            return result

        # Test the skill if requested and executor available
        if test_before_save and self.executor:
            try:
                test_result = await self._test_skill(code, name, test_params or {})
                result.test_result = test_result

                if not test_result.get("success") and not force_save:
                    result.error = f"Test failed: {test_result.get('error', 'unknown')}"
                    self._record_failure(name, code, result.error)
                    self._attempts.append(result)
                    return result

            except Exception as e:
                result.error = f"Test error: {e}"
                self._record_failure(name, code, result.error)
                self._attempts.append(result)
                return result

        # Save to library
        if self.auto_save or force_save:
            try:
                self.library.save(name, code, overwrite=force_save)
                result.persisted = True
                logger.info(f"Saved new skill: {name}")
            except Exception as e:
                result.error = f"Failed to save: {e}"
                self._attempts.append(result)
                return result

        result.success = True
        self._attempts.append(result)
        return result

    async def _test_skill(
        self,
        code: str,
        name: str,
        params: dict[str, Any],
    ) -> dict:
        """Test a skill with the executor."""
        if not self.executor:
            return {"success": True, "skipped": True}

        try:
            execution = await self.executor.execute_code(
                code=code,
                skill_name=name,
                params=params,
                timeout=30.0,
                persist=False,
            )

            return {
                "success": execution.success,
                "stopped_reason": execution.stopped_reason,
                "actions_taken": execution.actions_taken,
                "turns_elapsed": execution.turns_elapsed,
                "error": execution.error,
            }

        except Exception as e:
            return {
                "success": False,
                "error": str(e),
            }

    def _record_failure(self, name: str, code: str, error: str) -> None:
        """Record a failed synthesis attempt."""
        if name not in self._failed_codes:
            self._failed_codes[name] = []
        self._failed_codes[name].append(code)
        logger.warning(f"Skill synthesis failed for '{name}': {error}")

    def get_failed_attempts(self, skill_name: str) -> list[str]:
        """Get previously failed code attempts for a skill."""
        return self._failed_codes.get(skill_name, [])

    def get_recent_attempts(self, limit: int = 10) -> list[SynthesisResult]:
        """Get recent synthesis attempts."""
        return self._attempts[-limit:]

    def get_statistics(self) -> dict:
        """Get synthesis statistics."""
        total = len(self._attempts)
        successful = sum(1 for a in self._attempts if a.success)
        persisted = sum(1 for a in self._attempts if a.persisted)

        return {
            "total_attempts": total,
            "successful": successful,
            "persisted": persisted,
            "success_rate": successful / total if total > 0 else 0,
            "unique_skills_attempted": len(self._failed_codes),
        }

    def clear_history(self) -> None:
        """Clear synthesis history."""
        self._attempts.clear()
        self._failed_codes.clear()


def enhance_skill_code(code: str, skill_name: str) -> str:
    """
    Enhance skill code with standard boilerplate if missing.

    Args:
        code: Original skill code
        skill_name: Name of the skill

    Returns:
        Enhanced code with safety checks
    """
    enhanced = code

    # Ensure SkillResult import hint is present
    if "SkillResult" not in code:
        # Note: SkillResult is pre-injected by sandbox, but this helps readability
        pass

    # Add basic safety checks if missing
    safety_checks = []

    if "is_done" not in code:
        safety_checks.append("""
    # Check for game over
    if nh.is_done:
        return SkillResult.stopped("game_over", success=False, actions=0, turns=0)
""")

    if "max_" not in code and "range(" not in code:
        safety_checks.append("""
    # Safety: limit iterations
    max_iterations = 100
""")

    # Insert safety checks after function definition
    if safety_checks:
        # Find the line after async def
        lines = enhanced.split("\n")
        for i, line in enumerate(lines):
            if line.strip().startswith("async def"):
                # Find the docstring end or first code line
                j = i + 1
                in_docstring = False
                while j < len(lines):
                    stripped = lines[j].strip()
                    if stripped.startswith('"""') or stripped.startswith("'''"):
                        if in_docstring:
                            j += 1
                            break
                        in_docstring = True
                    elif not in_docstring and stripped and not stripped.startswith("#"):
                        break
                    j += 1

                # Insert safety checks
                indent = "    "  # Standard 4-space indent
                for check in safety_checks:
                    lines.insert(j, check)
                    j += 1
                break

        enhanced = "\n".join(lines)

    return enhanced


def extract_skill_docstring(code: str) -> str | None:
    """
    Extract the docstring from skill code.

    Args:
        code: Python skill code

    Returns:
        Docstring content or None
    """
    import ast

    try:
        tree = ast.parse(code)
        for node in ast.walk(tree):
            if isinstance(node, ast.AsyncFunctionDef):
                return ast.get_docstring(node)
    except SyntaxError:
        pass

    return None
